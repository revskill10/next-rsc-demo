/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * NocoDB
 * Create APIs at the speed of your thoughts
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://nocodedb-demo.herokuapp.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Articles
 */
export interface Articles {
    /**
     * 
     * @type {string}
     * @memberof Articles
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Articles
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof Articles
     */
    authorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Articles
     */
    slug?: string;
    /**
     * 
     * @type {number}
     * @memberof Articles
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface ArticlesNested
 */
export interface ArticlesNested {
    /**
     * 
     * @type {string}
     * @memberof ArticlesNested
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticlesNested
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticlesNested
     */
    authorId?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticlesNested
     */
    slug?: string;
    /**
     * 
     * @type {number}
     * @memberof ArticlesNested
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface Profiles
 */
export interface Profiles {
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    website?: string;
}

/**
 * 
 * @export
 * @interface ProfilesNested
 */
export interface ProfilesNested {
    /**
     * 
     * @type {string}
     * @memberof ProfilesNested
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfilesNested
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfilesNested
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfilesNested
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfilesNested
     */
    website?: string;
}

/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User extends UserAuth {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstname?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastname?: string;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    roles?: any;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    emailVerified?: boolean;
}

/**
 * 
 * @export
 * @interface UserAuth
 */
export interface UserAuth {
    /**
     * 
     * @type {string}
     * @memberof UserAuth
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuth
     */
    password?: string;
}


/**
 * ArticlesApi - fetch parameter creator
 * @export
 */
export const ArticlesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new Articles
         * @param {Articles} body Articles object that needs to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArticles(body: Articles, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addArticles.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Articles" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [func] Comma separated aggregate functions
         * @param {string} [having] Having expression
         * @param {string} [fields] Comma separated fields from the model
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesAggregate(columnName?: string, func?: string, having?: string, fields?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/aggregate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (func !== undefined) {
                localVarQueryParameter['func'] = func;
            }

            if (having !== undefined) {
                localVarQueryParameter['having'] = having;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesDistinct(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/distinct`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [columnName] Column name
         * @param {number} [min] min value
         * @param {number} [max] max value
         * @param {number} [step] step value
         * @param {number} [steps] steps value
         * @param {string} [func] comma separated aggregation functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesDistribution(columnName?: string, min?: number, max?: number, step?: number, steps?: number, func?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/distribution`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (steps !== undefined) {
                localVarQueryParameter['steps'] = steps;
            }

            if (func !== undefined) {
                localVarQueryParameter['func'] = func;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Group by column
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fieldst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesGroupByColumn(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/groupby`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk Articles insert
         * @param {Array<Articles>} body Articles objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkArticlesInsert(body: Array<Articles>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bulkArticlesInsert.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Articles&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Articles
         * @summary Check Articles with provided ID exists
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkArticlesExists(articlesId: string, options: any = {}): FetchArgs {
            // verify required parameter 'articlesId' is not null or undefined
            if (articlesId === null || articlesId === undefined) {
                throw new RequiredError('articlesId','Required parameter articlesId was null or undefined when calling checkArticlesExists.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/{ArticlesId}/exists`
                .replace(`{${"ArticlesId"}}`, encodeURIComponent(String(articlesId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Articles
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticles(articlesId: string, options: any = {}): FetchArgs {
            // verify required parameter 'articlesId' is not null or undefined
            if (articlesId === null || articlesId === undefined) {
                throw new RequiredError('articlesId','Required parameter articlesId was null or undefined when calling deleteArticles.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/{ArticlesId}`
                .replace(`{${"ArticlesId"}}`, encodeURIComponent(String(articlesId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Articles
         * @param {Array<Articles>} body Articles objects contains id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticles_1(body: Array<Articles>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteArticles_1.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Articles&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneArticles(fields?: string, where?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticles(fields?: string, bt?: string, hm?: string, mm?: string, where?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (bt !== undefined) {
                localVarQueryParameter['bt'] = bt;
            }

            if (hm !== undefined) {
                localVarQueryParameter['hm'] = hm;
            }

            if (mm !== undefined) {
                localVarQueryParameter['mm'] = mm;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Articles
         * @summary Find Articles by ID
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticlesById(articlesId: string, bt?: string, hm?: string, mm?: string, options: any = {}): FetchArgs {
            // verify required parameter 'articlesId' is not null or undefined
            if (articlesId === null || articlesId === undefined) {
                throw new RequiredError('articlesId','Required parameter articlesId was null or undefined when calling getArticlesById.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/{ArticlesId}`
                .replace(`{${"ArticlesId"}}`, encodeURIComponent(String(articlesId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (bt !== undefined) {
                localVarQueryParameter['bt'] = bt;
            }

            if (hm !== undefined) {
                localVarQueryParameter['hm'] = hm;
            }

            if (mm !== undefined) {
                localVarQueryParameter['mm'] = mm;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Articles count
         * @param {string} [where] Where expression
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticlesCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Articles
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {Articles} body Articles object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticles(articlesId: string, body: Articles, options: any = {}): FetchArgs {
            // verify required parameter 'articlesId' is not null or undefined
            if (articlesId === null || articlesId === undefined) {
                throw new RequiredError('articlesId','Required parameter articlesId was null or undefined when calling updateArticles.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateArticles.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/{ArticlesId}`
                .replace(`{${"ArticlesId"}}`, encodeURIComponent(String(articlesId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Articles" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Articles
         * @param {Array<Articles>} body Articles objects with id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticles_2(body: Array<Articles>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateArticles_2.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Articles/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Articles&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArticlesApi - functional programming interface
 * @export
 */
export const ArticlesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new Articles
         * @param {Articles} body Articles object that needs to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArticles(body: Articles, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).addArticles(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [func] Comma separated aggregate functions
         * @param {string} [having] Having expression
         * @param {string} [fields] Comma separated fields from the model
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesAggregate(columnName?: string, func?: string, having?: string, fields?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Articles> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).articlesAggregate(columnName, func, having, fields, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesDistinct(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).articlesDistinct(columnName, where, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [columnName] Column name
         * @param {number} [min] min value
         * @param {number} [max] max value
         * @param {number} [step] step value
         * @param {number} [steps] steps value
         * @param {string} [func] comma separated aggregation functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesDistribution(columnName?: string, min?: number, max?: number, step?: number, steps?: number, func?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).articlesDistribution(columnName, min, max, step, steps, func, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Group by column
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fieldst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesGroupByColumn(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Articles> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).articlesGroupByColumn(columnName, where, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bulk Articles insert
         * @param {Array<Articles>} body Articles objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkArticlesInsert(body: Array<Articles>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).bulkArticlesInsert(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a single Articles
         * @summary Check Articles with provided ID exists
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkArticlesExists(articlesId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).checkArticlesExists(articlesId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a Articles
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticles(articlesId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).deleteArticles(articlesId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a Articles
         * @param {Array<Articles>} body Articles objects contains id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticles_1(body: Array<Articles>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).deleteArticles_1(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneArticles(fields?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Articles> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).findOneArticles(fields, where, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get list
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticles(fields?: string, bt?: string, hm?: string, mm?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ArticlesNested>> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).getArticles(fields, bt, hm, mm, where, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a single Articles
         * @summary Find Articles by ID
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticlesById(articlesId: string, bt?: string, hm?: string, mm?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArticlesNested> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).getArticlesById(articlesId, bt, hm, mm, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Articles count
         * @param {string} [where] Where expression
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticlesCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).getArticlesCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a Articles
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {Articles} body Articles object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticles(articlesId: string, body: Articles, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).updateArticles(articlesId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a Articles
         * @param {Array<Articles>} body Articles objects with id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticles_2(body: Array<Articles>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArticlesApiFetchParamCreator(configuration).updateArticles_2(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArticlesApi - factory interface
 * @export
 */
export const ArticlesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a new Articles
         * @param {Articles} body Articles object that needs to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArticles(body: Articles, options?: any) {
            return ArticlesApiFp(configuration).addArticles(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [func] Comma separated aggregate functions
         * @param {string} [having] Having expression
         * @param {string} [fields] Comma separated fields from the model
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesAggregate(columnName?: string, func?: string, having?: string, fields?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ArticlesApiFp(configuration).articlesAggregate(columnName, func, having, fields, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesDistinct(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ArticlesApiFp(configuration).articlesDistinct(columnName, where, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} [columnName] Column name
         * @param {number} [min] min value
         * @param {number} [max] max value
         * @param {number} [step] step value
         * @param {number} [steps] steps value
         * @param {string} [func] comma separated aggregation functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesDistribution(columnName?: string, min?: number, max?: number, step?: number, steps?: number, func?: string, options?: any) {
            return ArticlesApiFp(configuration).articlesDistribution(columnName, min, max, step, steps, func, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Group by column
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fieldst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesGroupByColumn(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ArticlesApiFp(configuration).articlesGroupByColumn(columnName, where, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bulk Articles insert
         * @param {Array<Articles>} body Articles objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkArticlesInsert(body: Array<Articles>, options?: any) {
            return ArticlesApiFp(configuration).bulkArticlesInsert(body, options)(fetch, basePath);
        },
        /**
         * Returns a single Articles
         * @summary Check Articles with provided ID exists
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkArticlesExists(articlesId: string, options?: any) {
            return ArticlesApiFp(configuration).checkArticlesExists(articlesId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a Articles
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticles(articlesId: string, options?: any) {
            return ArticlesApiFp(configuration).deleteArticles(articlesId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a Articles
         * @param {Array<Articles>} body Articles objects contains id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticles_1(body: Array<Articles>, options?: any) {
            return ArticlesApiFp(configuration).deleteArticles_1(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneArticles(fields?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ArticlesApiFp(configuration).findOneArticles(fields, where, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get list
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticles(fields?: string, bt?: string, hm?: string, mm?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ArticlesApiFp(configuration).getArticles(fields, bt, hm, mm, where, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * Returns a single Articles
         * @summary Find Articles by ID
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticlesById(articlesId: string, bt?: string, hm?: string, mm?: string, options?: any) {
            return ArticlesApiFp(configuration).getArticlesById(articlesId, bt, hm, mm, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Articles count
         * @param {string} [where] Where expression
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticlesCount(where?: string, options?: any) {
            return ArticlesApiFp(configuration).getArticlesCount(where, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a Articles
         * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
         * @param {Articles} body Articles object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticles(articlesId: string, body: Articles, options?: any) {
            return ArticlesApiFp(configuration).updateArticles(articlesId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a Articles
         * @param {Array<Articles>} body Articles objects with id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticles_2(body: Array<Articles>, options?: any) {
            return ArticlesApiFp(configuration).updateArticles_2(body, options)(fetch, basePath);
        },
    };
};

/**
 * ArticlesApi - object-oriented interface
 * @export
 * @class ArticlesApi
 * @extends {BaseAPI}
 */
export class ArticlesApi extends BaseAPI {
    /**
     * 
     * @summary Add a new Articles
     * @param {Articles} body Articles object that needs to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public addArticles(body: Articles, options?: any) {
        return ArticlesApiFp(this.configuration).addArticles(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get first one from filtered data
     * @param {string} [columnName] Column name
     * @param {string} [func] Comma separated aggregate functions
     * @param {string} [having] Having expression
     * @param {string} [fields] Comma separated fields from the model
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public articlesAggregate(columnName?: string, func?: string, having?: string, fields?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ArticlesApiFp(this.configuration).articlesAggregate(columnName, func, having, fields, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get first one from filtered data
     * @param {string} [columnName] Column name
     * @param {string} [where] Where expression
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public articlesDistinct(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ArticlesApiFp(this.configuration).articlesDistinct(columnName, where, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 
     * @param {string} [columnName] Column name
     * @param {number} [min] min value
     * @param {number} [max] max value
     * @param {number} [step] step value
     * @param {number} [steps] steps value
     * @param {string} [func] comma separated aggregation functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public articlesDistribution(columnName?: string, min?: number, max?: number, step?: number, steps?: number, func?: string, options?: any) {
        return ArticlesApiFp(this.configuration).articlesDistribution(columnName, min, max, step, steps, func, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Group by column
     * @param {string} [columnName] Column name
     * @param {string} [where] Where expression
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fieldst
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public articlesGroupByColumn(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ArticlesApiFp(this.configuration).articlesGroupByColumn(columnName, where, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bulk Articles insert
     * @param {Array<Articles>} body Articles objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public bulkArticlesInsert(body: Array<Articles>, options?: any) {
        return ArticlesApiFp(this.configuration).bulkArticlesInsert(body, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a single Articles
     * @summary Check Articles with provided ID exists
     * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public checkArticlesExists(articlesId: string, options?: any) {
        return ArticlesApiFp(this.configuration).checkArticlesExists(articlesId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a Articles
     * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public deleteArticles(articlesId: string, options?: any) {
        return ArticlesApiFp(this.configuration).deleteArticles(articlesId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a Articles
     * @param {Array<Articles>} body Articles objects contains id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public deleteArticles_1(body: Array<Articles>, options?: any) {
        return ArticlesApiFp(this.configuration).deleteArticles_1(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get first one from filtered data
     * @param {string} [fields] Comma separated fields from the model
     * @param {string} [where] Where expression
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public findOneArticles(fields?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ArticlesApiFp(this.configuration).findOneArticles(fields, where, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get list
     * @param {string} [fields] Comma separated fields from the model
     * @param {string} [bt] Comma separated parent table names(Belongs To)
     * @param {string} [hm] Comma separated child table names(Has Many)
     * @param {string} [mm] Comma separated child table names(Many to Many)
     * @param {string} [where] Where expression
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public getArticles(fields?: string, bt?: string, hm?: string, mm?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ArticlesApiFp(this.configuration).getArticles(fields, bt, hm, mm, where, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a single Articles
     * @summary Find Articles by ID
     * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
     * @param {string} [bt] Comma separated parent table names(Belongs To)
     * @param {string} [hm] Comma separated child table names(Has Many)
     * @param {string} [mm] Comma separated child table names(Many to Many)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public getArticlesById(articlesId: string, bt?: string, hm?: string, mm?: string, options?: any) {
        return ArticlesApiFp(this.configuration).getArticlesById(articlesId, bt, hm, mm, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Articles count
     * @param {string} [where] Where expression
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public getArticlesCount(where?: string, options?: any) {
        return ArticlesApiFp(this.configuration).getArticlesCount(where, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a Articles
     * @param {string} articlesId ID of Articles to return. In case of composite key provide keys separated by ___
     * @param {Articles} body Articles object that needs to be added to the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public updateArticles(articlesId: string, body: Articles, options?: any) {
        return ArticlesApiFp(this.configuration).updateArticles(articlesId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a Articles
     * @param {Array<Articles>} body Articles objects with id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public updateArticles_2(body: Array<Articles>, options?: any) {
        return ArticlesApiFp(this.configuration).updateArticles_2(body, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Email validate link
         * @param {string} tokenId random token id received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailValidate(tokenId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling emailValidate.');
            }
            const localVarPath = `/auth/email/validate/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User login
         * @param {UserAuth} body Authentication user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: UserAuth, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/auth/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserAuth" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user details
         * @param {Body} body Current password and new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordChange(body: Body, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling passwordChange.');
            }
            const localVarPath = `/user/password/change`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Password Forgot
         * @param {Body} body Email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordForgot(body: Body, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling passwordForgot.');
            }
            const localVarPath = `/auth/password/forgot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Password reset
         * @param {string} tokenId random token id received
         * @param {Body} body Reset password details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordReset(tokenId: string, body: Body, options: any = {}): FetchArgs {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling passwordReset.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling passwordReset.');
            }
            const localVarPath = `/auth/password/reset/`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate password reset token
         * @param {string} tokenId random token id received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetTokenValidate(tokenId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling passwordResetTokenValidate.');
            }
            const localVarPath = `/auth/token/validate/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User signup
         * @param {User} body Signup user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(body: User, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling signup.');
            }
            const localVarPath = `/auth/signup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user details
         * @param {User} body Updated user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDetails(body: User, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUserDetails.');
            }
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDetails(options: any = {}): FetchArgs {
            const localVarPath = `/user/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Email validate link
         * @param {string} tokenId random token id received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailValidate(tokenId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).emailValidate(tokenId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary User login
         * @param {UserAuth} body Authentication user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: UserAuth, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Token> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update user details
         * @param {Body} body Current password and new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordChange(body: Body, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).passwordChange(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Password Forgot
         * @param {Body} body Email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordForgot(body: Body, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).passwordForgot(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Password reset
         * @param {string} tokenId random token id received
         * @param {Body} body Reset password details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordReset(tokenId: string, body: Body, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).passwordReset(tokenId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Validate password reset token
         * @param {string} tokenId random token id received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetTokenValidate(tokenId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).passwordResetTokenValidate(tokenId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary User signup
         * @param {User} body Signup user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Token> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).signup(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update user details
         * @param {User} body Updated user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDetails(body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).updateUserDetails(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDetails(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).userDetails(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Email validate link
         * @param {string} tokenId random token id received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailValidate(tokenId: string, options?: any) {
            return AuthenticationApiFp(configuration).emailValidate(tokenId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary User login
         * @param {UserAuth} body Authentication user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: UserAuth, options?: any) {
            return AuthenticationApiFp(configuration).login(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update user details
         * @param {Body} body Current password and new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordChange(body: Body, options?: any) {
            return AuthenticationApiFp(configuration).passwordChange(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Password Forgot
         * @param {Body} body Email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordForgot(body: Body, options?: any) {
            return AuthenticationApiFp(configuration).passwordForgot(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Password reset
         * @param {string} tokenId random token id received
         * @param {Body} body Reset password details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordReset(tokenId: string, body: Body, options?: any) {
            return AuthenticationApiFp(configuration).passwordReset(tokenId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Validate password reset token
         * @param {string} tokenId random token id received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetTokenValidate(tokenId: string, options?: any) {
            return AuthenticationApiFp(configuration).passwordResetTokenValidate(tokenId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary User signup
         * @param {User} body Signup user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(body: User, options?: any) {
            return AuthenticationApiFp(configuration).signup(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update user details
         * @param {User} body Updated user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDetails(body: User, options?: any) {
            return AuthenticationApiFp(configuration).updateUserDetails(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDetails(options?: any) {
            return AuthenticationApiFp(configuration).userDetails(options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Email validate link
     * @param {string} tokenId random token id received
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public emailValidate(tokenId: string, options?: any) {
        return AuthenticationApiFp(this.configuration).emailValidate(tokenId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary User login
     * @param {UserAuth} body Authentication user details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(body: UserAuth, options?: any) {
        return AuthenticationApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update user details
     * @param {Body} body Current password and new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public passwordChange(body: Body, options?: any) {
        return AuthenticationApiFp(this.configuration).passwordChange(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Password Forgot
     * @param {Body} body Email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public passwordForgot(body: Body, options?: any) {
        return AuthenticationApiFp(this.configuration).passwordForgot(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Password reset
     * @param {string} tokenId random token id received
     * @param {Body} body Reset password details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public passwordReset(tokenId: string, body: Body, options?: any) {
        return AuthenticationApiFp(this.configuration).passwordReset(tokenId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Validate password reset token
     * @param {string} tokenId random token id received
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public passwordResetTokenValidate(tokenId: string, options?: any) {
        return AuthenticationApiFp(this.configuration).passwordResetTokenValidate(tokenId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary User signup
     * @param {User} body Signup user details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signup(body: User, options?: any) {
        return AuthenticationApiFp(this.configuration).signup(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update user details
     * @param {User} body Updated user details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateUserDetails(body: User, options?: any) {
        return AuthenticationApiFp(this.configuration).updateUserDetails(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public userDetails(options?: any) {
        return AuthenticationApiFp(this.configuration).userDetails(options)(this.fetch, this.basePath);
    }

}

/**
 * ProfilesApi - fetch parameter creator
 * @export
 */
export const ProfilesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new Profiles
         * @param {Profiles} body Profiles object that needs to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProfiles(body: Profiles, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addProfiles.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Profiles" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk Profiles insert
         * @param {Array<Profiles>} body Profiles objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkProfilesInsert(body: Array<Profiles>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bulkProfilesInsert.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Profiles&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Profiles
         * @summary Check Profiles with provided ID exists
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkProfilesExists(profilesId: string, options: any = {}): FetchArgs {
            // verify required parameter 'profilesId' is not null or undefined
            if (profilesId === null || profilesId === undefined) {
                throw new RequiredError('profilesId','Required parameter profilesId was null or undefined when calling checkProfilesExists.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/{ProfilesId}/exists`
                .replace(`{${"ProfilesId"}}`, encodeURIComponent(String(profilesId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Profiles
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfiles(profilesId: string, options: any = {}): FetchArgs {
            // verify required parameter 'profilesId' is not null or undefined
            if (profilesId === null || profilesId === undefined) {
                throw new RequiredError('profilesId','Required parameter profilesId was null or undefined when calling deleteProfiles.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/{ProfilesId}`
                .replace(`{${"ProfilesId"}}`, encodeURIComponent(String(profilesId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Profiles
         * @param {Array<Profiles>} body Profiles objects contains id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfiles_1(body: Array<Profiles>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteProfiles_1.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Profiles&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProfiles(fields?: string, where?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/findOne`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfiles(fields?: string, bt?: string, hm?: string, mm?: string, where?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (bt !== undefined) {
                localVarQueryParameter['bt'] = bt;
            }

            if (hm !== undefined) {
                localVarQueryParameter['hm'] = hm;
            }

            if (mm !== undefined) {
                localVarQueryParameter['mm'] = mm;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Profiles
         * @summary Find Profiles by ID
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilesById(profilesId: string, bt?: string, hm?: string, mm?: string, options: any = {}): FetchArgs {
            // verify required parameter 'profilesId' is not null or undefined
            if (profilesId === null || profilesId === undefined) {
                throw new RequiredError('profilesId','Required parameter profilesId was null or undefined when calling getProfilesById.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/{ProfilesId}`
                .replace(`{${"ProfilesId"}}`, encodeURIComponent(String(profilesId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (bt !== undefined) {
                localVarQueryParameter['bt'] = bt;
            }

            if (hm !== undefined) {
                localVarQueryParameter['hm'] = hm;
            }

            if (mm !== undefined) {
                localVarQueryParameter['mm'] = mm;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Profiles count
         * @param {string} [where] Where expression
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilesCount(where?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [func] Comma separated aggregate functions
         * @param {string} [having] Having expression
         * @param {string} [fields] Comma separated fields from the model
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesAggregate(columnName?: string, func?: string, having?: string, fields?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/aggregate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (func !== undefined) {
                localVarQueryParameter['func'] = func;
            }

            if (having !== undefined) {
                localVarQueryParameter['having'] = having;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDistinct(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/distinct`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [columnName] Column name
         * @param {number} [min] min value
         * @param {number} [max] max value
         * @param {number} [step] step value
         * @param {number} [steps] steps value
         * @param {string} [func] comma separated aggregation functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDistribution(columnName?: string, min?: number, max?: number, step?: number, steps?: number, func?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/distribution`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (steps !== undefined) {
                localVarQueryParameter['steps'] = steps;
            }

            if (func !== undefined) {
                localVarQueryParameter['func'] = func;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Group by column
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fieldst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGroupByColumn(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/groupby`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Profiles
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {Profiles} body Profiles object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfiles(profilesId: string, body: Profiles, options: any = {}): FetchArgs {
            // verify required parameter 'profilesId' is not null or undefined
            if (profilesId === null || profilesId === undefined) {
                throw new RequiredError('profilesId','Required parameter profilesId was null or undefined when calling updateProfiles.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProfiles.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/{ProfilesId}`
                .replace(`{${"ProfilesId"}}`, encodeURIComponent(String(profilesId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Profiles" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Profiles
         * @param {Array<Profiles>} body Profiles objects with id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfiles_2(body: Array<Profiles>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProfiles_2.');
            }
            const localVarPath = `/nc/lama_su_gqmy/api/v1/Profiles/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication xcAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("xc-auth")
					: configuration.apiKey;
                localVarHeaderParameter["xc-auth"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Profiles&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new Profiles
         * @param {Profiles} body Profiles object that needs to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProfiles(body: Profiles, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).addProfiles(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bulk Profiles insert
         * @param {Array<Profiles>} body Profiles objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkProfilesInsert(body: Array<Profiles>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).bulkProfilesInsert(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a single Profiles
         * @summary Check Profiles with provided ID exists
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkProfilesExists(profilesId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).checkProfilesExists(profilesId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a Profiles
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfiles(profilesId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).deleteProfiles(profilesId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a Profiles
         * @param {Array<Profiles>} body Profiles objects contains id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfiles_1(body: Array<Profiles>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).deleteProfiles_1(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProfiles(fields?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Profiles> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).findOneProfiles(fields, where, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get list
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfiles(fields?: string, bt?: string, hm?: string, mm?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProfilesNested>> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).getProfiles(fields, bt, hm, mm, where, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a single Profiles
         * @summary Find Profiles by ID
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilesById(profilesId: string, bt?: string, hm?: string, mm?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProfilesNested> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).getProfilesById(profilesId, bt, hm, mm, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Profiles count
         * @param {string} [where] Where expression
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilesCount(where?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).getProfilesCount(where, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [func] Comma separated aggregate functions
         * @param {string} [having] Having expression
         * @param {string} [fields] Comma separated fields from the model
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesAggregate(columnName?: string, func?: string, having?: string, fields?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Profiles> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).profilesAggregate(columnName, func, having, fields, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDistinct(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).profilesDistinct(columnName, where, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [columnName] Column name
         * @param {number} [min] min value
         * @param {number} [max] max value
         * @param {number} [step] step value
         * @param {number} [steps] steps value
         * @param {string} [func] comma separated aggregation functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDistribution(columnName?: string, min?: number, max?: number, step?: number, steps?: number, func?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).profilesDistribution(columnName, min, max, step, steps, func, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Group by column
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fieldst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGroupByColumn(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Profiles> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).profilesGroupByColumn(columnName, where, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a Profiles
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {Profiles} body Profiles object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfiles(profilesId: string, body: Profiles, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).updateProfiles(profilesId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a Profiles
         * @param {Array<Profiles>} body Profiles objects with id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfiles_2(body: Array<Profiles>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).updateProfiles_2(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a new Profiles
         * @param {Profiles} body Profiles object that needs to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProfiles(body: Profiles, options?: any) {
            return ProfilesApiFp(configuration).addProfiles(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bulk Profiles insert
         * @param {Array<Profiles>} body Profiles objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkProfilesInsert(body: Array<Profiles>, options?: any) {
            return ProfilesApiFp(configuration).bulkProfilesInsert(body, options)(fetch, basePath);
        },
        /**
         * Returns a single Profiles
         * @summary Check Profiles with provided ID exists
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkProfilesExists(profilesId: string, options?: any) {
            return ProfilesApiFp(configuration).checkProfilesExists(profilesId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a Profiles
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfiles(profilesId: string, options?: any) {
            return ProfilesApiFp(configuration).deleteProfiles(profilesId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a Profiles
         * @param {Array<Profiles>} body Profiles objects contains id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfiles_1(body: Array<Profiles>, options?: any) {
            return ProfilesApiFp(configuration).deleteProfiles_1(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProfiles(fields?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ProfilesApiFp(configuration).findOneProfiles(fields, where, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get list
         * @param {string} [fields] Comma separated fields from the model
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfiles(fields?: string, bt?: string, hm?: string, mm?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ProfilesApiFp(configuration).getProfiles(fields, bt, hm, mm, where, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * Returns a single Profiles
         * @summary Find Profiles by ID
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {string} [bt] Comma separated parent table names(Belongs To)
         * @param {string} [hm] Comma separated child table names(Has Many)
         * @param {string} [mm] Comma separated child table names(Many to Many)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilesById(profilesId: string, bt?: string, hm?: string, mm?: string, options?: any) {
            return ProfilesApiFp(configuration).getProfilesById(profilesId, bt, hm, mm, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Profiles count
         * @param {string} [where] Where expression
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilesCount(where?: string, options?: any) {
            return ProfilesApiFp(configuration).getProfilesCount(where, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [func] Comma separated aggregate functions
         * @param {string} [having] Having expression
         * @param {string} [fields] Comma separated fields from the model
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesAggregate(columnName?: string, func?: string, having?: string, fields?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ProfilesApiFp(configuration).profilesAggregate(columnName, func, having, fields, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get first one from filtered data
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDistinct(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ProfilesApiFp(configuration).profilesDistinct(columnName, where, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} [columnName] Column name
         * @param {number} [min] min value
         * @param {number} [max] max value
         * @param {number} [step] step value
         * @param {number} [steps] steps value
         * @param {string} [func] comma separated aggregation functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDistribution(columnName?: string, min?: number, max?: number, step?: number, steps?: number, func?: string, options?: any) {
            return ProfilesApiFp(configuration).profilesDistribution(columnName, min, max, step, steps, func, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Group by column
         * @param {string} [columnName] Column name
         * @param {string} [where] Where expression
         * @param {number} [limit] Page size limit
         * @param {number} [offset] Pagination offset
         * @param {string} [sort] Comma separated sort fieldst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGroupByColumn(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return ProfilesApiFp(configuration).profilesGroupByColumn(columnName, where, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a Profiles
         * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
         * @param {Profiles} body Profiles object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfiles(profilesId: string, body: Profiles, options?: any) {
            return ProfilesApiFp(configuration).updateProfiles(profilesId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a Profiles
         * @param {Array<Profiles>} body Profiles objects with id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfiles_2(body: Array<Profiles>, options?: any) {
            return ProfilesApiFp(configuration).updateProfiles_2(body, options)(fetch, basePath);
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * 
     * @summary Add a new Profiles
     * @param {Profiles} body Profiles object that needs to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public addProfiles(body: Profiles, options?: any) {
        return ProfilesApiFp(this.configuration).addProfiles(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bulk Profiles insert
     * @param {Array<Profiles>} body Profiles objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public bulkProfilesInsert(body: Array<Profiles>, options?: any) {
        return ProfilesApiFp(this.configuration).bulkProfilesInsert(body, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a single Profiles
     * @summary Check Profiles with provided ID exists
     * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public checkProfilesExists(profilesId: string, options?: any) {
        return ProfilesApiFp(this.configuration).checkProfilesExists(profilesId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a Profiles
     * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public deleteProfiles(profilesId: string, options?: any) {
        return ProfilesApiFp(this.configuration).deleteProfiles(profilesId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a Profiles
     * @param {Array<Profiles>} body Profiles objects contains id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public deleteProfiles_1(body: Array<Profiles>, options?: any) {
        return ProfilesApiFp(this.configuration).deleteProfiles_1(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get first one from filtered data
     * @param {string} [fields] Comma separated fields from the model
     * @param {string} [where] Where expression
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public findOneProfiles(fields?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ProfilesApiFp(this.configuration).findOneProfiles(fields, where, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get list
     * @param {string} [fields] Comma separated fields from the model
     * @param {string} [bt] Comma separated parent table names(Belongs To)
     * @param {string} [hm] Comma separated child table names(Has Many)
     * @param {string} [mm] Comma separated child table names(Many to Many)
     * @param {string} [where] Where expression
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public getProfiles(fields?: string, bt?: string, hm?: string, mm?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ProfilesApiFp(this.configuration).getProfiles(fields, bt, hm, mm, where, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a single Profiles
     * @summary Find Profiles by ID
     * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
     * @param {string} [bt] Comma separated parent table names(Belongs To)
     * @param {string} [hm] Comma separated child table names(Has Many)
     * @param {string} [mm] Comma separated child table names(Many to Many)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public getProfilesById(profilesId: string, bt?: string, hm?: string, mm?: string, options?: any) {
        return ProfilesApiFp(this.configuration).getProfilesById(profilesId, bt, hm, mm, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Profiles count
     * @param {string} [where] Where expression
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public getProfilesCount(where?: string, options?: any) {
        return ProfilesApiFp(this.configuration).getProfilesCount(where, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get first one from filtered data
     * @param {string} [columnName] Column name
     * @param {string} [func] Comma separated aggregate functions
     * @param {string} [having] Having expression
     * @param {string} [fields] Comma separated fields from the model
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesAggregate(columnName?: string, func?: string, having?: string, fields?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ProfilesApiFp(this.configuration).profilesAggregate(columnName, func, having, fields, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get first one from filtered data
     * @param {string} [columnName] Column name
     * @param {string} [where] Where expression
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesDistinct(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ProfilesApiFp(this.configuration).profilesDistinct(columnName, where, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 
     * @param {string} [columnName] Column name
     * @param {number} [min] min value
     * @param {number} [max] max value
     * @param {number} [step] step value
     * @param {number} [steps] steps value
     * @param {string} [func] comma separated aggregation functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesDistribution(columnName?: string, min?: number, max?: number, step?: number, steps?: number, func?: string, options?: any) {
        return ProfilesApiFp(this.configuration).profilesDistribution(columnName, min, max, step, steps, func, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Group by column
     * @param {string} [columnName] Column name
     * @param {string} [where] Where expression
     * @param {number} [limit] Page size limit
     * @param {number} [offset] Pagination offset
     * @param {string} [sort] Comma separated sort fieldst
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesGroupByColumn(columnName?: string, where?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return ProfilesApiFp(this.configuration).profilesGroupByColumn(columnName, where, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a Profiles
     * @param {string} profilesId ID of Profiles to return. In case of composite key provide keys separated by ___
     * @param {Profiles} body Profiles object that needs to be added to the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public updateProfiles(profilesId: string, body: Profiles, options?: any) {
        return ProfilesApiFp(this.configuration).updateProfiles(profilesId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a Profiles
     * @param {Array<Profiles>} body Profiles objects with id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public updateProfiles_2(body: Array<Profiles>, options?: any) {
        return ProfilesApiFp(this.configuration).updateProfiles_2(body, options)(this.fetch, this.basePath);
    }

}

